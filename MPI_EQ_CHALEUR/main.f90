program main
  use mpi
  use ModData
  use ModF
  use ModGC
  use ModSOL
  implicit none
!********************************************************************************
  !MAIN CONTIENT:
  !L'INITIALISATION DES PARAMETRES DU PROBLEME ET VECTEURS 
  !LA BOUCLE ITERATIVE EN TEMPS POUR RESOUDRE A.U=b ET L'ECRITURE DE LA SOLUTION
  !LE CODAGE DE LA SOLUTION EXACTE
  !LA CONCATENATION DES FICHIERS SOLUTIONS (RANG ET TEMPS DEPENDANT)
  !SUBROUTINES: POUR LE CODAGE EN ESPAGE, LA CHARGE LOCALE ET GLOBALE
!*******************************************************************************
  INTEGER,parameter::RK_MAIN=8
  !PARAMETRES DATA.F90:
  INTEGER::userchoice,sysmove!choix du cas, choix visualisation sol
  REAL(RK_MAIN)::Lx,Ly,D !LONG,LARG,COEF_DIFFUSION
  INTEGER::Nx,Ny !NBR PTS EN X, EN Y
  INTEGER::ITMAX!NBR ITERATION EN TEMPS
  REAL(RK_MAIN)::DT!LE PAS DE TEMPS
  !PAS D'ESPACE:
  REAL(RK_MAIN)::DX,DY
  !POUR LA CHARGE:
  INTEGER::DIM!DIMENSION DE LA MATRICE:=NBR PTS DE CALCUL:=NBR PTS INT:= CHARGE A REPARTIR ENTRE PROCS
  INTEGER::it1,itN !CHARGE NUMEROTATION GLO
  INTEGER::S1,S2,INTER_X !LOCALE EN X, NBR_PTS INT EN X
  INTEGER::INTER_Y !LOCALE FIXE(MODE1) EN Y:=NBR_PTS INT EN Y
  INTEGER,DIMENSION(:,:),ALLOCATABLE::GAP !LOCALE MOBILE (MODE2) EN Y
  !STOCKAGE D'ESPACE(UNIQUEMENT PTS INT)
  REAL(RK_MAIN),DIMENSION(:),ALLOCATABLE::X,Y
  !CONDI DE BORDS SI CST:(CAS 1 et CAS 3)
  REAL(RK_MAIN)::G,H !G->SUD ET NORD(y=0 et y=Ly) H->OUEST ET EST(x=0 et x=lx)
  !SI NON CST (CAS 2): pas de stockage mais calcul.
  ! VARIABLES TEMPS:
  REAL(RK_MAIN)::t !le temps t=k*DT
  INTEGER::k !l'ITERANT SUR LA BOUCLE EN TEMPS
  !COEF DE LA MATRICE:
  REAL(RK_MAIN)::A,AP,AL !A|AP|0|0|AL 1er ligne Nx=NY=6
  !BORNE EN X ET EN Y:
  INTEGER::IXMAX,IYMAX! on a Nx pts en X on va de 0 Ã  Nx-1
  !NOM FICHIER RANG:
  CHARACTER(LEN=3)::rank
  CHARACTER(LEN=4),parameter::PARAMETRES_USER='DATA'
  CHARACTER(LEN=20)::NFILE,NT,OUT_FILE
  CHARACTER(LEN=1)::ESPACE
  !POUR ENVI PARA:
  INTEGER::rang,Np,stateinfo
  INTEGER,DIMENSION(MPI_STATUS_SIZE)::status
  !MODE DE REPARTION:
  INTEGER,PARAMETER::MODE=2
  !VECTEURS U,F,b. A.U=b=UO+DT.F+CONDITIONS DE BORDS
  REAL(RK_MAIN),DIMENSION(:),ALLOCATABLE::U,F!,b
  REAL(RK_MAIN)::F_VAR
  !TEMPS CPU:
  REAL(RK_MAIN)::TPS1,TPS2,MAX_TPS
  !TOLERANCE DU GC:
  REAL(RK_MAIN),PARAMETER::TOL=0.0000000000000001d0!0.000000000001d0
  !ITERATION DU GC:
  INTEGER::KMAX
  !VECTEUR DU GC:r=RESIDU,z=AP,p=DIRECTION DE DESCENTE
  REAL(RK_MAIN),DIMENSION(:),ALLOCATABLE::r,z,p
  !PI:
  REAL(RK_MAIN),PARAMETER::PI=3.141592653589793
  !TEMPS DES COMMUNICATION, PRODUIT MATRICE/VECTEUR, MPI_ALLREDUCE:
  REAL(RK_GC)::Tpmv,Tcomm,Tall,MAX_pmv,MAX_comm,MAX_all,WR1,WR2,WR,MAX_WR
  !PIVOT DE COMMUNICATION:
  INTEGER::PIVOT
   !****
  INTEGER::i,j
  !********* DEBUT REGION PARA:
  CALL MPI_INIT(stateinfo) !INITIALISATION DU //LISME
  CALL MPI_COMM_RANK(MPI_COMM_WORLD,rang,stateinfo) !ON RECUPERE LES RANGS AU SEIN DE L'ENSEMBLE MPI_COMM_WORLD 
  CALL MPI_COMM_SIZE(MPI_COMM_WORLD,Np,stateinfo)   !ET LE NOMBRE DU PROCESSUS
  !INIT TEMPS CPU:
  TPS1=MPI_WTIME()
  !LECTURE DE DATA:
  CALL INI_PARA(rang,Lx,Ly,D,Nx,Ny,PARAMETRES_USER,sysmove,userchoice,DT,ITMAX)
  !INITIALISATION DES VARIABLES:
  INTER_Y=Ny-2;INTER_X=Nx-2;IYMAX=Ny-1;IXMAX=Nx-1
  DY=Ly/IYMAX;DX=Lx/IXMAX
  !INITIALISATION DIMENSION MATRICE ET COEF MATRICE:
  DIM=INTER_X*INTER_Y
  AP=D*DT/(DY**2);AL=D*DT/(DX**2);A=1+2*AP+2*AL
  !ON FIXE KMAX LE NOMBRE D'ITERATION DU GC:
  KMAX=2*DIM !ON SAIT QUE LE GC CONVERGE EN DIM ITERATION, ON MET 2*DIM.
  

  IF(MODE==1)THEN
     !INITIALISATION REPARTITION SUIVANT LE MODE 1:
     CALL MODE1(rang,Np,INTER_X,INTER_Y,S1,S2,it1,itN,DX,DY,X,Y)
     !INFO: DANS LE REPERTOIRE M1, ON ENREGISTRE LA CHARGE PAR PROCS
     WRITE(rank,fmt='(1I3)')rang
     OPEN(rang+10,file='M1/MAP_'//trim(adjustl(rank))//'.dat')
     DO i=S1,S2
        DO j=1,INTER_Y
           WRITE(10+rang,*)X(i),Y(j),rang
        END DO
     END DO
     CLOSE(rang+10)
     ALLOCATE(GAP(S1:S2,1:2));GAP(:,1)=1;GAP(:,2)=INTER_Y
  ELSE IF(MODE==2)THEN
     !INITIALISATION REPARTITION SUIVANT LE MODE 2:
     CALL MODE2(rang,Np,DIM,IXMAX,INTER_X,INTER_Y,S1,S2,GAP,it1,itN,DX,DY,X,Y)
     !INFO: DANS LE REPERTOIRE: M1, ON ENREGISTRE LA CHARGE PAR PROCS
     WRITE(rank,fmt='(1I3)')rang
     OPEN(rang+10,file='M1/MAP_'//trim(adjustl(rank))//'.dat')
     DO i=S1,S2
        DO j=GAP(i,1),GAP(i,2)
           WRITE(10+rang,*)X(i),Y(j),rang
        END DO
     END DO
     CLOSE(rang+10)
  END IF


  !INITIALISATION U,b,F,BC:
  ALLOCATE(U(it1-INTER_Y:itN+INTER_Y),F(it1:itN))
  !INITIALISATION DES TEMPS MAX:
  MAX_TPS=0.0d0
  MAX_pmv=0.0d0;MAX_comm=0.0d0;MAX_all=0.0d0
  WR1=0.0d0;WR2=0.0d0;WR=0.0d0;MAX_WR=0.0d0
  !PIVOT DE COMMUNICATION:
  PIVOT=(Np-mod(Np,2))/2
  !SELON LE CHOIX DE L'UTILISATEUR SUR LA FONCTION SOURCE:
  SELECT CASE(userchoice)
  CASE(1)!POUR F=F1=2*(y-y^2+x-x^2) ET G=H=0
     U(it1:itN)=2.0d0! U=Uo=2: INITIALISATION
     WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             0,ITMAX,Lx,Ly,X,Y)!ON ENREGISTRE U Au TEMPS 0 sec (CF: REPERTOIRE SOL_NUMERIQUE)
     WR2=MPI_WTIME()
     WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL F1(it1,itN,S1,S2,INTER_Y,GAP,X,Y,F)!ON CALCUL LA FONCTION SOURCE
     CALL WR_F(rang,it1,itN,INTER_Y,F,S1,S2,GAP,X,Y) ! ON ENREGISTRE LA FONCTION SOURCE (CF REPERTOIRE: F)
     
     F_VAR=0.0d0
     ALLOCATE(r(it1:itN),z(it1:itN),p(it1-INTER_Y:itN+INTER_Y))! ALLOCATION DES VECTEUR POUR LE GC(GRADIENT CONJUGUE)
     DO k=1,ITMAX! BOUCLE EN TEMPS POUR RESOUDRE: A.U=Uo+DT*F+CONDITIONS DE BORDS
        U(it1-INTER_Y:it1-1)=0.0d0;U(itN+1:itN+INTER_Y)=0.0d0!A CHAQUE ITERATION EN TEMPS, LES BORDS U SONT REMIS A ZERO
        CALL GC(A,AP,AL,U,F,F_VAR,userchoice,DT,TOL,KMAX,it1,itN&
             ,INTER_Y,INTER_X,S1,S2,GAP,Np,rang,stateinfo,status,mode,r,z,p,&
             Tpmv,Tcomm,Tall,PIVOT,k)!ON APPELLE LE GC POUR CALCULER LA SOLUTION AU TEMPS k*DT
        MAX_pmv=MAX_pmv+Tpmv;MAX_comm=MAX_comm+Tcomm;MAX_all=MAX_all+Tall!ON SUM SUR LES TEMPS MAX
        WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
        CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             k,ITMAX,Lx,Ly,X,Y)! ON ENREGISTRE LA SOLUTION U AU TEMPS k*DT (CF: REPERTOIRE SOL_NUMERIQUE)
        WR2=MPI_WTIME()
        WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     END DO
     
  CASE(2)!POUR F=F2=G=H=SIN(x)+COS(y)
     U(it1:itN)=2.0d0! U=Uo=2: INITIALISATION
     WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             0,ITMAX,Lx,Ly,X,Y)!ON ENREGISTRE U Au TEMPS 0 sec
     WR2=MPI_WTIME()
     WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL F2(it1,itN,S1,S2,INTER_Y,GAP,X,Y,F)!ON CALCUL LA FONCTION SOURCE
     CALL WR_F(rang,it1,itN,INTER_Y,F,S1,S2,GAP,X,Y) ! ON ENREGISTRE LA FONCTION SOURCE (CF REPERTOIRE: F)
     
     
     F_VAR=0.0d0
     ALLOCATE(r(it1:itN),z(it1:itN),p(it1-INTER_Y:itN+INTER_Y))! ALLOCATION DES VECTEUR POUR LE GC(GRADIENT CONJUGUE)
     DO k=1,ITMAX! BOUCLE EN TEMPS POUR RESOUDRE: A.U=Uo+DT*F+CONDITIONS DE BORDS
        U(it1-INTER_Y:it1-1)=0.0d0;U(itN+1:itN+INTER_Y)=0.0d0!A CHAQUE ITERATION EN TEMPS, LES BORDS U SONT REMIS A ZERO
        CALL BC(AP,AL,userchoice,S1,S2,GAP,it1,itN,INTER_Y,INTER_X&
          ,X,Y,DX,DY,Lx,Ly,U(it1:itN))!LA BC EST NON NULLE ON DOIT L'APPELE A CHAQUE ITERATION EN TEMPS
        CALL GC(A,AP,AL,U,F,F_VAR,userchoice,DT,TOL,KMAX,it1,itN&
             ,INTER_Y,INTER_X,S1,S2,GAP,Np,rang,stateinfo,status,mode,r,z,p,&
             Tpmv,Tcomm,Tall,PIVOT,k)!ON APPELLE LE GC POUR CALCULER LA SOLUTION AU TEMPS k*DT
        MAX_pmv=MAX_pmv+Tpmv;MAX_comm=MAX_comm+Tcomm;MAX_all=MAX_all+Tall!ON SUM SUR LES TEMPS MAX
        WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
        CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             k,ITMAX,Lx,Ly,X,Y)! ON ENREGISTRE LA SOLUTION U AU TEMPS k*DT (CF: REPERTOIRE SOL_NUMERIQUE)
        WR2=MPI_WTIME()
        WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     END DO
     
  CASE(3)!POUR F=F3=EXP(-(X-0.5*Lx)^2)*EXP(-(Y-0.5*Ly)^2)*COS(0.5*t*Pi) ET G=0, H=1
     U(it1:itN)=5.0d0! U=Uo=5: INITIALISATION
     WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             0,ITMAX,Lx,Ly,X,Y)!ON ENREGISTRE U Au TEMPS 0 sec
     WR2=MPI_WTIME()
     WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     CALL F3_FIXE(Lx,Ly,it1,itN,S1,S2,INTER_Y,GAP,X,Y,F)!ON CALCUL LA PARITE FIXE DE LA FONCTION SOURCE
     CALL WR_F(rang,it1,itN,INTER_Y,F,S1,S2,GAP,X,Y) ! ON ENREGISTRE LA FONCTION SOURCE (CF REPERTOIRE: F)
     ALLOCATE(r(it1:itN),z(it1:itN),p(it1-INTER_Y:itN+INTER_Y))! ALLOCATION DES VECTEUR POUR LE GC(GRADIENT CONJUGUE)
     DO k=1,ITMAX! BOUCLE EN TEMPS POUR RESOUDRE: A.U=Uo+DT*F+CONDITIONS DE BORDS
        U(it1-INTER_Y:it1-1)=0.0d0;U(itN+1:itN+INTER_Y)=0.0d0
        t=k*DT! ICI PB INSTATIONNAIRE
        F_VAR=cos(PI*t/2)! ON CALCUL LA PARTIE VARIABLE DE LA FONCTION SOURCE  
        CALL BC(AP,AL,userchoice,S1,S2,GAP,it1,itN,INTER_Y,INTER_X&
             ,X,Y,DX,DY,Lx,Ly,U(it1:itN))!LA BC EST NON NULLE ON DOIT L'APPELE A CHAQUE ITERATION EN TEMPS
        CALL GC(A,AP,AL,U,F,F_VAR,userchoice,DT,TOL,KMAX,it1,itN&
             ,INTER_Y,INTER_X,S1,S2,GAP,Np,rang,stateinfo,status,mode,r,z,p,&
             Tpmv,Tcomm,Tall,PIVOT,k)!APPELLE DU GC
        MAX_pmv=MAX_pmv+Tpmv;MAX_comm=MAX_comm+Tcomm;MAX_all=MAX_all+Tall!ON SUM SUR LES TEMPS MAX
        WR1=MPI_WTIME()!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
        CALL WR_U(U,it1,itN,INTER_X,INTER_Y,S1,S2,GAP,userchoice,rang,&
             k,ITMAX,Lx,Ly,X,Y)! ON ENREGISTRE LA SOLUTION U AU TEMPS k*DT (CF: REPERTOIRE SOL_NUMERIQUE)
        WR2=MPI_WTIME()
        WR=WR+WR2-WR1!POUR LE TEMPS D'ECRITURE DE LA SOLUTION
     END DO
     
  END SELECT
  CALL MPI_ALLREDUCE(WR,MAX_WR,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,stateinfo)
  DEALLOCATE(r,z,p)! VECTEUR POUR LE GC ON PEUT DEALLOCATE

  !VERIFICATION AVEC UNE SOLUTION ANALYTIQUE POUR CAS 1 Et CAS 2:
  IF(userchoice==1.OR.userchoice==2)THEN
     CALL UEXACT(U,userchoice,it1,itN,INTER_Y,INTER_X,X,Y,S1,S2,GAP,stateinfo,rang)
  END IF! VOIR LE REPERTOIRE: EXACTE_ERREUR 

  DEALLOCATE(U,F)     !VECTEURS ET TABLEAU ON DEALLOCATE CAR ILS NE SONT PLUS APPELE 
  DEALLOCATE(X,Y,GAP)


  !FIN TPS CPU:
  TPS2=MPI_WTIME()
  CALL MPI_ALLREDUCE(TPS2-TPS1,MAX_TPS,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,stateinfo)
  !ON REND LE TEMPS TOTAL ET LA SUM DES TEMPS MAX:
  IF(rang==0)THEN
     PRINT*,'RANG',rang,'MAX TEMPS TOTAL=',MAX_TPS,'SUM_MAX:'
     PRINT*,'COMM=',MAX_comm,'PMV=',MAX_pmv,'allRED=',MAX_all,'Ecriture=',MAX_WR
  END IF
  
  !********* FIN REGION PARA:
  CALL MPI_FINALIZE(stateinfo)

  !VIZUALISATION SEQUENTIELLE: ON CONCATENE POUR UNE ITERATION EN TEMPS DONNEE, LES FICHIERS DE RANG DIFFERENTS DANS UN FICHIER
  IF(rang==0.AND.sysmove==1)THEN
     ESPACE=' '
     DO i=0,ITMAX
        WRITE(NT,fmt='(1I3)')i;     
        NFILE='U_ME*'//'_T'//trim(adjustl(NT));OUT_FILE='UT'//trim(adjustl(NT))//'.dat'
        !ON CONCATENE POUR UNE ITERATION EN TEMPS DONNEE, LES FICHIERS DE RANG DIFFERENTS DANS UN FICHIER
        CALL system('cat SOL_NUMERIQUE/'//NFILE//' >> SOL_NUMERIQUE/'//OUT_FILE)
        CALL system('rm SOL_NUMERIQUE/'//NFILE)
        OPEN(10,file='SOL_NUMERIQUE/'//OUT_FILE,position='append')
        SELECT CASE(userchoice)!ICI IL FAUT RAJOUTER LES POINTS AUX COINS DU DOMAINES
        CASE(1)
           WRITE(10,*)0.0d0,0.0d0,0.0d0;WRITE(10,*)Lx,0.0d0,0.0d0
           WRITE(10,*)0.0d0,Ly,0.0d0;WRITE(10,*)Lx,Ly,0.0d0
        CASE(2)
           WRITE(10,*)0.0d0,0.0d0,1.0d0;WRITE(10,*)Lx,0.0d0,1.0d0+sin(Lx)
           WRITE(10,*)0.0d0,Ly,cos(Ly);WRITE(10,*)Lx,Ly,cos(Ly)+sin(Lx)
        CASE(3)
           WRITE(10,*)0.0d0,0.0d0,0.5d0;WRITE(10,*)Lx,0.0d0,0.5d0!TEMPERATURES IMPOSEES DIFFERENTES, ON MOYENNE:((G+H)/2)
           WRITE(10,*)0.0d0,Ly,0.5d0;WRITE(10,*)Lx,Ly,0.5d0
        END SELECT
        WRITE(10,fmt='(1A1)')ESPACE
        WRITE(10,fmt='(1A1)')ESPACE
        CLOSE(10)
        !ON CONCATENE POUR UNE ITERATION EN TEMPS DONNEE, LES FICHIERS DE TEMPS DIFFERENTS DANS UN FICHIER
        CALL system('cat SOL_NUMERIQUE/'//OUT_FILE//' >> SOL_NUMERIQUE/U.dat')
        CALL system('rm SOL_NUMERIQUE/'//OUT_FILE)
     END DO    
     !A LA FIN, IL RESTE UN FICHIER OU LA SOLUTION EN TEMPS EST SOUS FORME D'INDEX GNUPLOT
     !ON APPELLE LA SUBROUTIEN DE VISUALISATION:
     CALL VIZU_SOL_NUM(userchoice,DT,ITMAX,Nx,Ny)
  END IF


contains
!************* !MODE DE REPARTITION 2: ******************************************************** 
  !CALCUL LA CHARGE GLOBALE PAR PROCS POUR EN DEDUIRE LA CHARGE LOCALE EN X ET Y
  !LA DIFFERENCE MAXIMALE DE CHARGE ENTRE 2 PROCS EST TOUJOURS DE 1
  !UTILISABLE POUR 1<=Np<=DIM, DIM=INTER_X*INTER_Y LE NBR DE POINTS DE CALCULS
  SUBROUTINE MODE2(rang,Np,DIM,IXMAX,INTER_X,INTER_Y,S1,S2,GAP,it1,itN,DX,DY,X,Y)
    INTEGER,INTENT(in)::rang,Np,DIM,IXMAX,INTER_X,INTER_Y
    REAL(RK_MAIN),INTENT(IN)::DX,DY
    INTEGER,INTENT(out)::S1,S2,it1,itN
    REAL(RK_MAIN),DIMENSION(:),ALLOCATABLE::X,Y
    INTEGER,DIMENSION(:,:),ALLOCATABLE::GAP
    CALL CHARGE_GLO(rang,Np,DIM,it1,itN)
    CALL ALLOC_X(Np,IXMAX,INTER_Y,it1,itN,S1,S2)
    CALL ALLOC_Y(rang,Np,S1,S2,it1,itN,INTER_Y,INTER_X,GAP)
    ALLOCATE(X(S1:S2));ALLOCATE(Y(1:INTER_Y))
    CALL SPACE_X(S1,S2,DX,X);CALL SPACE_Y(INTER_Y,DY,Y)
    
  END SUBROUTINE MODE2
  
  SUBROUTINE CHARGE_GLO(rang,Np,DIM,it1,itN)!CALCUL DE CHARGE CLASSIQUE
    INTEGER,INTENT(in)::rang,Np,DIM
    INTEGER,INTENT(out)::it1,itN
    REAL::CO_RE
    INTEGER::m
    IF(Np==1)THEN
       it1=1;itN=DIM
    ELSE
       CO_RE=DIM/Np;m=mod(DIM,Np)
       IF(rang<m)THEN
          it1=rang*(CO_RE+1)+1;itN=(rang+1)*(CO_RE+1)
       ELSE
          it1=1+m+rang*CO_RE;itN=it1+CO_re-1
       END IF
    END IF

  END SUBROUTINE CHARGE_GLO

  !CALCULE LA CHARGE LOCALE EN X EN UTILISANT LA CHARGE GLOBALE(it1:itN):
  SUBROUTINE ALLOC_X(Np,IXMAX,INTER_Y,it1,itN,S1,S2)
    INTEGER,INTENT(IN)::Np,IXMAX,INTER_Y,it1,itN
    INTEGER,INTENT(out)::S1,S2
    INTEGER::i,j,k,mult
    INTEGER::AFF1,AFF2
    IF(Np==1)THEN
       S1=1;S2=IXMAX-1
    ELSE
       AFF1=0;AFF2=0
       i=1
       DO WHILE(i<IXMAX.AND.(AFF1+AFF2)<2)
          mult=i*INTER_Y
          IF((AFF1==0).AND. it1<=mult)THEN!PERMET DE DETERMINER LA PRJECTION DE it1 SUR L'AXE X
             AFF1=1;S1=i
          END IF
          IF((AFF2==0).AND. itN<=mult)THEN!!PERMET DE DETERMINER LA PRJECTION DE itN SUR L'AXE X
             AFF2=1;S2=i
          END IF
          IF(AFF1==0.OR.AFF2==0)THEN
             i=i+1
          END IF
       END DO
    END IF
  END SUBROUTINE ALLOC_X
  !ON UTILISE LA CHARGE EN X ET LA CHARGE GLOBALE POUR CALCULER LA CHARGE EN Y:
  SUBROUTINE ALLOC_Y(rang,Np,S1,S2,it1,itN,INTER_Y,INTER_X,GAP)
    INTEGER,INTENT(IN)::rang,Np,S1,S2,it1,itN,INTER_X,INTER_Y
    INTEGER,DIMENSION(:,:),ALLOCATABLE::TAB
    INTEGER,DIMENSION(:,:),ALLOCATABLE,INTENT(out)::GAP
    INTEGER::i,j,k
    IF(Np==1)THEN
       ALLOCATE(GAP(1:INTER_X,1:2));GAP(:,1)=1;GAP(:,2)=INTER_Y
    ELSE
       ALLOCATE(TAB(S1:S2,0:INTER_Y+1))
       TAB=0
       k=it1;i=S1;j=0
       DO WHILE(k<itN+1)!POUR k allant de it1 Ã  itN (charge globale) 
          j=k-(i-1)*INTER_Y!ON CONNAIT k et i POUR TOUS LES PROCS, ON PEUT EN DEDUIRE j (i,j charges locales en X et Y)
          TAB(i,j)=TAB(i,j-1)+1! ON COMPTE la charge en j
          k=k+1
          IF(j==INTER_Y)THEN!ON PASSE A LA COLONNE SUIVANTE
             i=i+1
          END IF
       END DO
       ALLOCATE(GAP(S1:S2,1:2))
       DO i=S1,S2!CHARGE LOCALE EN X
          DO j=1,INTER_Y!NBR LIGNE
             IF(TAB(i,j)==1)THEN!<=>LE PREMIER ELEMENT CONNU DU PROCS DANS UNE COLONNE
                GAP(i,1)=j! ON RECUREPE L'INFORMATION
             END IF
             IF(TAB(i,j)>TAB(i,j-1).AND.TAB(i,j)>TAB(i,j+1))THEN!LE PLUS GRAND ELEMENT DE TAB(,)
                GAP(i,2)=j                                      !<=>AU DERNIER ELEMENT CONNU DANS LA COLONNE PAR UN PROC  
             END IF
          END DO
       END DO
       DEALLOCATE(TAB)
    END IF
  END SUBROUTINE ALLOC_Y
  
!**********  !MODE 1 DE REPARTITION: ***********************************************************
!SE BASE SUR LA CHARGE EN X POUR CALCULER LA CHARGE TOTALE(GLOBALE)
!INDUIT POUR MOD(DIM,Np)/=0 UNE DIFFERENCE DE CHARGE = A INTER_Y ENTRE 2 PROCS
!UTILISABLE POUR Np<=INTER_X
  SUBROUTINE MODE1(rang,Np,INTER_X,INTER_Y,S1,S2,it1,itN,DX,DY,X,Y)
    INTEGER,INTENT(in)::rang,Np,INTER_X,INTER_Y
    REAL(RK_MAIN),INTENT(IN)::DX,DY
    INTEGER,INTENT(out)::S1,S2,it1,itN
    REAL(RK_MAIN),DIMENSION(:),ALLOCATABLE::X,Y
    
    !CHARGE EN X:
    CALL CHARGE_X(rang,Np,INTER_X,S1,S2)
    ALLOCATE(X(S1:S2),Y(1:INTER_Y))! LES PROCS CONNAISSENT TOUT DE Y 
    !CHARGE TOT:
    CALL CHARGE_TOT(S1,S2,INTER_Y,it1,itN)
    !INI ESPACE:
    CALL SPACE_X(S1,S2,DX,X);CALL SPACE_Y(INTER_Y,DY,Y)
        
  END SUBROUTINE MODE1
  
  SUBROUTINE CHARGE_X(rang,Np,INTER_X,S1,S2)!REPERTITION CLASSIQUE DE LA CHARGE EN X
    INTEGER,INTENT(in)::rang,Np,INTER_X
    INTEGER,INTENT(OUT)::S1,S2
    REAL::CO_RE!COEFF_REPARTION
    IF(Np==1)THEN
       S1=1;S2=INTER_X
    ELSE
       CO_RE=INTER_X/Np
       IF(rang<mod(INTER_X,Np))THEN
          S1=rang*(CO_RE+1)+1;S2=(rang+1)*(CO_RE+1)
       ELSE
          S1=1+mod(INTER_X,Np)+rang*CO_RE;S2=S1+CO_RE-1
       END IF
    END IF       
  END SUBROUTINE CHARGE_X

  SUBROUTINE SPACE_X(S1,S2,DX,X)! DISCRETISATION DE L'ESPACE EN X 
    INTEGER,INTENT(IN)::S1,S2
    REAL(RK_MAIN),INTENT(in)::DX
    REAL(RK_MAIN),DIMENSION(S1:S2),INTENT(out)::X
    INTEGER::i
    DO i=S1,S2
       X(i)=i*DX
    END DO
  END SUBROUTINE SPACE_X

  SUBROUTINE SPACE_Y(INTER_Y,DY,Y)! DISCRETISATION DE L'ESPACE EN Y
    INTEGER,INTENT(IN)::INTER_Y
    REAL(RK_MAIN),INTENT(in)::DY
    REAL(RK_MAIN),DIMENSION(1:INTER_Y),INTENT(out)::Y
    INTEGER::j
    DO j=1,INTER_Y
       Y(j)=j*DY
    END DO
  END SUBROUTINE SPACE_Y

  SUBROUTINE CHARGE_TOT(S1,S2,INTER_Y,it1,itN)! CHARGE GLOBALE PAR PROCS
    INTEGER,INTENT(in)::S1,S2,INTER_Y
    INTEGER,INTENT(out)::it1,itN
    it1=(S1-1)*INTER_Y+1;itN=S2*INTER_Y
  END SUBROUTINE CHARGE_TOT
  
end program main
